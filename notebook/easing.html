<!DOCTYPE html><html lang="en"><head>
<meta charset="utf-8">
<title>Easing Notebook</title>
<link href="/css-mint.min.css" rel="stylesheet" type="text/css" media="all">
<link href="/misclabs.css" rel="stylesheet" type="text/css" media="all">
<link href="notebook.css" rel="stylesheet" type="text/css" media="all">
<style type="text/css">
.dmWrap{margin:0;padding:0;width:854px;height:240px;}
.dmWrap canvas{float:right;}
</style>
</head><body>
<div class="nt">
# Easing Notebook

<div class="dmWrap">
	<canvas id="dm" class="sz240p"></canvas>
	<!-- <div><label for="dmX">X</label><input id="dmX" data-key="x" data-v-id="dmXv" type="range" min="0" max="350" value="0"><label id="dmXv">0</label></div> -->
	<label for="slctEs">Ease</label><select id="slctEs">
		<option value="lnr" selected>Linear</option>
		<option value="mesSmthStrt2">Smooth start 2</option>
		<option value="mesSmthStrt6">Smooth start 6</option>
		<option value="mesSmthStop2">Smooth stop 2</option>
		<option value="mesSmthStop6">Smooth stop 6</option>
		<option value="mesSmthStep2">Smooth step 2</option>
		<option value="mesSmthStep6">Smooth step 6</option>
		<option value="mesArch2">Arch 2</option>
	</select>
	<button id="btnPlyPs" type="button">Pause</button>
</div>

<em>Note</em>: these are just my personal notes and experiments. You're welcome to look and used them, but they're a mess and won't be cleaned-up.

## Terms and Uses
- 1D Nonlinear Transformations
- Easing functions on Steroids
- Normalized Utility Functions (AI)
- Used in Juice, Animation, AI
- SmoothStep, SmootherStep

## Motiviations

*Implicit* is a rule; does a test: are you on a circle? e.g. `x^2 + y^2 = 25`
vs.
*Parametric* takes a parameter and returns a value. e.g. `f(t) = [cos(t),sin(t)]1` Output can be multi-dimensional.

Most important ranges: [0,1] and [-1,1]. [0,1] can be percentage (shadow, luminance, falloff, complete, damage, cost, etc.). [-1,1] useful for deviations (noise, perturbation, terrain & map generation, distribution, sinusoidal, pusling) and anytime there is a baseline with variation. 

Note of taking a power of [0,1] range:
- Lowers the value
- Curve of odd/even powers being sideways-S/U shaped is not present in this range

Outputs: color, position, AI disposition, transparency, etc.

Opportunity: 
- anytime you have a single float to change 
- can be expressed as a single float
- time is involved

## Normalized Utility Functions (1D Normalized Nonlinear)
Transform `t` in `P(t)` w/o caring what `t` is.

*Normalized*:
- Range is `[0,1]`
- `P(0) = 0`
- `P(1) = 1`

*Nonlinear*: `P(t) != t`

Easing is the best name. A.K.A filter functions (artists), lerping functions (wrong!), tweening functions (animation).

Note: because `P(1) = 1` you always know where/when something will end

### Range-mapping
Mapping from range `m` to range `n` using an easing function. e.g. strength [3,18] to damage modifier [0, 5]
```
RangeMap(in, inStart, inEnd, outStart, outEnd)
{
	// in is assumed to be in [inStart, inEnd]
	let out = in - inStart; // out is in [0, inEnd-inStart]
	out /= (inEnd-inStart); // out is in [0,1]

	out = ease(out); // out is in [0,1]

	out *= (outEnd-outStart); // out is in [0, outRange]
	return out + outStart; // return is in [outStart, outEnd]
}
```
Anything that can be converted to [0,1] to anything that can be converted from [0,1]

### Functions

#### Techniques
- Raise to power: `t^N`
- Flip: `1-t`
- Mix: `Mix(a,b,weight,t) = a+(b-a)*weight` or `(1-weight)*a + weight*b`
- FakePow: `FakePow(x, 2.2) = (.8*x^2) + (.2*x^3)`
- CrossFade: `CrossFade(a,b,t) = Mix(a,b,t,t)`
- Scale: `Scale(Func,t) = t*Func(t)` Note: [0,1] * [0,1] = [0,1]
- ReverseScale: `ReverseScale(Func,t) = (1-t)*Func(t)`
- Nesting: `SmoothStop3(SmoothStart3(t)) = ???`

Note on FakePow: Mix can be used to avoid using pow to fractional exponents:
`SmoothStart2.2 = Mix(SmoothStart2, SmoothStart3, 0.2)` 99% accurate in [0,1] and 10x faster

#### SmoothStartN
`SmoothStartN(t) = t^N`

`N` is typically `[2,6]`

N > 4 should remove jerk

#### SmoothStopN

SmoothStop is Flip => Pow => Flip. Flip is `1-t`.

`SmoothStopN(t) = 1 - (1-t)^N`

#### SmoothStepN

CrossFade(SmoothStartN, SmoothStopN, t)

#### ArchN
`Arch2(t) = Scale(Flip(t)) = t*(1-t)`

#### BellCurveN
`BellCurve6(t) = SmoothStop3(t)*SmoothStart3(t)

#### Gamma Correction
FakePow2.2 = `t^2.2`

#### Bounce
Abs(Sin(t))
### Demo
Select function and show: scale, alpha, 1D position, this effects togehter, and show the graph!

### Questions and Research Topics
What other [0,1] transformations exist? How might this relate to transformations in different color spaces.

NormalizedBezier: https://www.youtube.com/watch?v=mr5xkf6zSzk&ab_channel=GDC timecode: 26:00

## Misc.
*sqrt* is slow. *pow* is even slower (it can do sqrt).

SmoothStart is a better name than EaseIn; 4 better than Quad (less ambiguity). A train easing into a station is the opposite of EaseIn, Quadratic is 2nd order polynomial. Names like EaseInQuad are bad.

## References
[Fast and Funky 1D Nonlinear Transformations](https://www.youtube.com/watch?v=mr5xkf6zSzk) by Squirrel Eiserloh

</div>

<script src="/marked.min.js"></script>
<script src="/msc.js"></script>
<script src="/mgl.js"></script>
<script src="/mes.js"></script>
<script src="mnb.js"></script>
<script>
function lnr(t){return t}

window.addEventListener("load", function ldPg(evnt){
	"use strict"
	window.removeEventListener(evnt.type,ldPg);
	mnbRndrMrkdwnByCls('nt')
	let isPlyng=true
	let esMp={lnr,mesSmthStrt2,mesSmthStrt6,
		mesSmthStop2,mesSmthStop6,
		mesSmthStep2,mesSmthStep6,
		mesArch2}
	let twn=mesNewTwn(2, 0, 1, mesUpdtPngPng, lnr)
	document.querySelector("#slctEs").addEventListener("change",(evnt)=>{
		evnt.preventDefault()
		//console.log("target",evnt.target,"currentTarget",evnt.currentTarget)
		let opts=evnt.target.options;
		twn.esFn=esMp[opts[opts.selectedIndex].value]
		console.log("selected",opts[opts.selectedIndex],"map",esMp,"fn",twn.esFn)
	})
	document.querySelector("#btnPlyPs").addEventListener("click",(evnt)=>{
		if (isPlyng) {
			evnt.target.innerText = "Play"
			isPlyng=false
		} else {
			evnt.target.innerText = "Pause"
			isPlyng=true
		}
	})
	let col=[0,1,0, 1]
	let dc=mglNewDc(document.querySelector("#dm"))
	let tckr=mscNewTckr() 
	let val=0
	setInterval(()=>{
		tckr.tck()
		if (isPlyng) {val=mesTckTwn(twn, tckr.dtS)}
		dc.begin()
		dc.rect(170,60,100,100, 0, val, col)
		dc.rect(280,60,100,100, 0, 1, [val,val,val,1])
		dc.rect(15+315*val,125,10,10, 0, 1, col)
		
		dc.rect(60,60,100,100, 0, 1, [0.1,0.1,0.1,1])
		for (let i=0; i<100; ++i) {
			dc.rect(10+i,110-twn.esFn(i/100.0)*100,1,1, 0, 1, col)
		}
		dc.end()
	}, 1000/30)
});	
</script>
</body></html>