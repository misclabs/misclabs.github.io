<!DOCTYPE html><html lang="en"><head>
<meta charset="utf-8">
<!-- <script src="http://google.github.io/tracing-framework/bin/wtf_trace_web_js_compiled.js"></script>
<script>
	var options = {
	  /* options, if any */
	};
	// Setup tracing with the given options.
	wtf.trace.prepare(options);
	// Optionally, create the on-screen HUD for better control.
	wtf.hud.prepare(options);
	// Start recording a trace immediately (if desired).
	wtf.trace.start(options);
  </script> -->
<title>WebGL Note 2 Notebook</title>
<link href="/css-mint.min.css" rel="stylesheet" type="text/css" media="all">
<link href="/misclabs.css" rel="stylesheet" type="text/css" media="all">
<link href="notebook.css" rel="stylesheet" type="text/css" media="all">
<style type="text/css">
.dmWrap{
	/* background:url(pattern_33.png) repeat; */
	/*background-color: black;*/
	margin:0;padding:0;
	width:854px;height:240px;
}
.dmWrap canvas{float:right;}
label{margin-right:8px}
</style>
</head><body>
<div class="note">
# WebGL: Draw Multiple Things Notebook

<div class="dmWrap">
<canvas id="dm" class="sz240p"></canvas>
<div><label for="dmX">X</label><input id="dmX" data-key="x" data-v-id="dmXv" type="range" min="0" max="350" value="0"><label id="dmXv">0</label></div>
<div><label for="dmY">Y</label><input id="dmY" data-key="y" data-v-id="dmYv" type="range" min="0" max="350" value="0"><label id="dmYv">0</label></div>
<div><label for="dmW">Width</label><input id="dmW" data-key="w" data-v-id="dmWv" type="range" min="0" max="350" value="0"><label id="dmWv">0</label></div>
<div><label for="dmH">Height</label><input id="dmH" data-key="h" data-v-id="dmHv" type="range" min="0" max="350" value="0"><label id="dmHv">0</label></div>
<div><label for="dmS">Scale X</label><input id="dmS" data-key="s" data-v-id="dmSv" type="range" min="-5.0" max="5.0" value="1"><label id="dmSv">1</label></div>
<div><label for="dmR">Rotation</label><input id="dmR" data-key="r" data-v-id="dmRv" type="range" min="0" max="360" value="0"><label id="dmRv">0</label></div>
</div>

<em>Note</em>: these are just my personal notes and experiments. You're welcome to look and used them, but they're a mess and won't be cleaned-up.

<canvas id="dm2" class="sz240p"></canvas>

## Flow on GPU

For each vertex provided the vertex shader is run and must produce at least `gl_Position` in clip space.

Assuming triangles, every 3 vertices are grouped into a trianlge and rastorized.

For each rasterized fragment the fragment shader is called with interpolated data and must produce a `gl_FragColor`. Or cancel processing the fragment?

	

### Varyings

Varyings are data passed from vertex shader to fragment shader. Varings are declared in the vertex shader and fragment shader. Varings are interpolated between there vertices at each fragment.

Vertex shader example:
```
varying vec4 v_color;
...
void main() {
	...
	v_color = gl_Position * 0.5 + 0.5;
}
```

Fragment shader example:
```
...
varying vec4 v_color;
void main() {
	gl_FragColor  v_color;
}
```

## User Flow

- Initialization
	- Create shader programs and get look up locations
	- Create buffers and upload static vertex data
	- Create textures and upload static textures
- Render Loop
	- Clear and set viewport
	- Set other global state (depth testing, culling, etc.)
	- For each object to draw
		- Activate a shader with `gl.useProgram`
		- Setup attributes; for each attribute
			- `gl.bindBuffer`
			- `gl.vertexAttribPointer`
			- `gl.enalbeVertexAttribArray`
		- Setup uniforms; for each uniform
			- `gl.uniformXXX`
			- `gl.activeTexture` and `gl.bindTexture`
		- Call `gl.drawArrays` or `gl.drawElements`
</div>
<script src="/marked.min.js"></script>
<script src="/mgl.js"></script>
<script src="mnb.js"></script>
<script id="vertSrc" type="GLSL">
uniform vec2 scrSz;uniform vec4 trans;attribute vec2 scrPos;void main(){/* Scale */ vec2 pos=scrPos*trans.w; /* Rotate */ vec2 r=vec2(sin(trans.z),cos(trans.z)); pos=vec2(pos.x*r.y+pos.y*r.x, pos.y*r.y-pos.x*r.x); /* Translate */ pos=pos+trans.xy; /* Clip space */ pos=((pos / scrSz) * 2.0) - 1.0; gl_Position=vec4(pos * vec2(1, -1), 0, 1); }
</script>
<script id="fragSrc" type="GLSL">
precision mediump float;uniform vec4 col;void main(){gl_FragColor=col;}
</script>
<script>
function newDc(canvas) {
	let {gc,prog}=mglInitCnvs(canvas, document.querySelector("#vertSrc").text, document.querySelector("#fragSrc").text);
	let scrSzLoc=gc.getUniformLocation(prog,"scrSz");
	let colLoc=gc.getUniformLocation(prog,"col");
	let transLoc=gc.getUniformLocation(prog,"trans");
	let posLoc=gc.getAttribLocation(prog,"scrPos");
	let posBuf=gc.createBuffer(), colBuf=gc.createBuffer()
	let posDt=[],objs=[]
	let bDrw=false
	let clrCol=[0,0,0,1]
	let pub={
		begin:function(){
			if(bDrw){throw new Error("Already began drawing")}
			bDrw=true
			mglUpdateCnvsSz(gc.canvas)
			let {w:sw,h:sh}=pub.scrSz()
			gc.viewport(0, 0, sw, sh)
			gc.clearColor(clrCol[0],clrCol[1],clrCol[2],clrCol[3])
			gc.clear(gc.COLOR_BUFFER_BIT)
			gc.useProgram(prog)
			gc.uniform2f(scrSzLoc, sw,sh)
		},
		end:function(){
			if (!bDrw) {throw new Error("Drawing never began")}
			function initAttr(loc, buf, dt, cTyp, cCnt, cNrm=false){
				gc.bindBuffer(gc.ARRAY_BUFFER,buf)
				gc.enableVertexAttribArray(loc)
				gc.vertexAttribPointer(loc, cCnt, cTyp, cNrm, 0, 0)
				gc.bufferData(gc.ARRAY_BUFFER,dt,gc.DYNAMIC_DRAW)
			}
			initAttr(posLoc, posBuf, new Float32Array(posDt), gc.FLOAT, 2)
			for (let i=0; i<objs.length; ++i) {
				gc.uniform4fv(colLoc, objs[i].col4fv)
				gc.uniform4fv(transLoc, objs[i].trans)
				gc.drawArrays(gc.TRIANGLES,objs[i].dtStrt,objs[i].dtCnt)
			}
			posDt.length=0
			objs.length=0
			bDrw=false
		},
		scrSz:function(){return{w:gc.canvas.width,h:gc.canvas.height}},
		tri:function(x1,y1, x2,y2, x3,y3, col4fv){
			objs.push({dtStrt:posDt.length/2,dtCnt:3,col4fv,trans:[0,0,0,1]})
			posDt.push(x1,y1, x2,y2, x3,y3)
		},
		rect:function(x,y, w,h, rot, s, col4fv){
			let lt=[-w/2.0,-h/2.0]
			let br=[w/2.0,h/2.0]
			objs.push({dtStrt:posDt.length/2,dtCnt:6,col4fv,trans:[x,y,rot,s]})
			posDt.push(
				lt[0],lt[1], w/2.0,-h/2.0, br[0],br[1],
				lt[0],lt[1], br[0],br[1], -w/2.0,h/2.0)
		}
	}
	return pub
}
window.addEventListener("load", function initializePage(evt) {
	"use strict"
	window.removeEventListener(evt.type, initializePage, false)
	mnbRndrMrkdwnByCls('note')
	startDemo1();
	startDemo2();
})
function startDemo1() {
	let dc=newDc(document.querySelector("#dm"))
	let color=[Math.random(),Math.random(),Math.random(), 1]
	let ui={x:0,y:0,w:100,h:30,s:1,r:0}
	function initSldr(id, v){
		let sldr=document.querySelector(id)
		let vlElm=document.querySelector("#"+sldr.dataset.vId)
		sldr.value=v
		let onInpt=(e)=>{
			ui[sldr.dataset.key]=parseInt(sldr.value,10)
			if (vlElm) {vlElm.textContent=sldr.value}
		}
		sldr.addEventListener("input",onInpt)
		onInpt({target:sldr})
	}
	initSldr("#dmX",100);initSldr("#dmY",100);initSldr("#dmW",50);initSldr("#dmH",30)
	initSldr("#dmR",0);initSldr("#dmS",1.0)
	let tickId=setInterval(()=>{
		dc.begin()
		dc.rect(ui.x,ui.y , ui.w,ui.h, ui.r*Math.PI/180, ui.s, color)
		dc.end()
	}, 1000/30)
}
function startDemo2() {
	let canvas=document.querySelector("#dm2");
	let dc=mglNewDc(canvas)
	let color=[Math.random(),Math.random(),Math.random()]
	
	let rects=[]
	let {w,h}=dc.scrSz()
	let cw=w/16.0, ch=h/9.0
	for (let i=0; i<16; ++i) {
		for (let j=0; j<9; ++j) {
			rects.push({
				x:i*cw+cw/2,y:j*ch+ch/2,
				w:cw,h:ch, s:0,r:0})
		}
	}
	let prevNow=performance.now()
	let tickId=setInterval(()=>{
		let now=performance.now();
		let dt=now-prevNow;
		dc.begin()
		for (let i=0; i < rects.length; ++i) {
			rects[i].s=Math.min(rects[i].s+dt/1000.0,2);
			rects[i].r=(rects[i].r+dt/1000.0)%360
			dc.rect(rects[i].x,rects[i].y,
				rects[i].w,rects[i].h, rects[i].r, rects[i].s,
				[0,0,0,0])
		}
		dc.end()
		prevNow=now;
	}, 1000/30)
}
</script>
</body></html>